## 동시성 제어 분석 보고서

### 1. 현재 구조에서의 동시성 문제

본 과제에서 제공된 `/database` 패키지의 구현체는 다음과 같다.

- `UserPointTable`
    - `Map<Long, UserPoint>` 를 사용하는 인메모리 테이블
    - `selectById(id)`, `insertOrUpdate(id, amount)` 제공
    - `synchronized` 처리가 되어 있지 않음
- `PointHistoryTable`
    - `List<PointHistory>` 기반의 인메모리 테이블
    - `insert`, `selectAllByUserId` 제공
    - 마찬가지로 동기화되지 않음

이 상태에서 여러 스레드가 동시에 같은 userId에 대해 `charge`/`use` 를 호출하면 다음 문제가 발생할 수 있다.

- **Lost Update(갱신 손실)**
    - 스레드 A, B가 같은 시점에 `selectById(1)` 을 호출해 둘 다 `1000` 을 읽고
    - 각각 100원씩 충전한 뒤 `1100` 으로 `insertOrUpdate` 를 호출하면
    - 최종 값은 `1200` 이 아니라 `1100` 이 될 수 있다.
- **잔고 부족 검증 실패**
    - `use` 로직은 `현재 포인트 >= 사용 금액` 인지 검사 후 차감한다.
    - 동시성 제어가 없으면 두 스레드가 동시에 검사해서 둘 다 성공으로 판단하고,
      최종 잔액이 0 미만으로 내려갈 수 있다.

즉, 현재 구조는 단일 스레드 환경에서는 문제 없지만, **멀티 스레드 환경에서는 계좌(포인트) 일관성이 깨질 수 있는 상태**다.

---

### 2. 고려한 동시성 제어 방식

1. **DB 레벨 비관적 락 (`SELECT ... FOR UPDATE`)**
    - 실제 RDBMS를 사용한다면 가장 흔한 방법.
    - 트랜잭션 안에서 레코드를 잠그고, 다른 트랜잭션의 갱신을 대기시킨다.
    - 이번 과제는 인메모리 테이블이고 트랜잭션/락 기능이 없기 때문에 적용 불가.

2. **낙관적 락 (버전 필드 + CAS)**
    - 엔티티에 `version` 필드를 두고, 갱신 시 `where id = ? and version = ?` 형태로 체크.
    - 버전이 다르면 재시도하는 방식.
    - 이번 과제의 `UserPoint`/`UserPointTable` 구조를 변경해야 하므로 `/database` 패키지 수정 금지 조건과 충돌.

3. **애플리케이션 레벨 락 (synchronized, ReentrantLock)**
    - 서비스 레이어에서 `userId` 를 기준으로 락을 잡고, **해당 유저에 대한 read-modify-write 를 한 번에 수행**.
    - `synchronized` 키워드로 메서드 전체를 막을 수도 있지만, 그러면 서로 다른 userId 도 서로 영향을 받게 되어 성능 저하가 크다.
    - 따라서 `userId` 별 `ReentrantLock` 을 생성해서, **하나의 유저에 대해서만 순차적으로 처리**하도록 구현하는 방식을 선택했다.

---

### 3. 최종 선택: 사용자별 ReentrantLock

본 과제에서는 **애플리케이션 레벨에서 userId 기준의 락을 관리하는 방식**을 선택했다.

- 구현 방식
    - `ConcurrentHashMap<Long, ReentrantLock>` 를 사용하여 userId -> 락 매핑을 관리
    - `charge`, `use` 로직 시작 전에 해당 userId 의 락을 획득하고, 종료 후 해제
    - 이렇게 하면 **같은 유저에 대한 요청은 반드시 순차적으로 처리**된다.
    - 서로 다른 유저는 서로 다른 락을 사용하므로 동시에 처리 가능

- 장점
    - `/database` 패키지를 변경하지 않고도 동시성 문제 해결 가능
    - 한 유저에 대해 "계좌 갱신" 로직 전체를 임계 영역으로 만들 수 있어 Lost Update 방지
    - 구현이 단순하고 테스트하기 쉽다.

- 단점 / 고려사항
    - userId 수가 매우 많아지면 `ConcurrentHashMap` 의 엔트리가 계속 늘어날 수 있다. (메모리 관리 필요)
    - 프로세스 하나 기준의 락이므로, **여러 서버(멀티 인스턴스)** 환경에서는 여전히 분산 락이 필요하다.
        - 과제 조건(분산 환경 고려 X)에 따라 이번 구현에서는 단일 인스턴스 기준으로만 해결했다.

---

### 4. 동시성 통합 테스트

동시성 제어가 실제로 동작하는지 확인하기 위해 다음과 같은 통합 테스트를 작성하였다.

1. **동시에 여러 번 충전하는 경우**
    - 100개의 스레드가 동시에 `charge(1L, 100)` 을 호출
    - 최종 잔액이 `100 * 100 = 10_000` 이고,
    - 히스토리 개수가 100개인지 검증
    - 동시성 제어가 없다면 Lost Update 로 인해 최종 잔액이 더 작게 나올 수 있다.

2. **동시에 여러 번 사용하여 잔고를 초과하는 경우**
    - 초기 잔액을 10_000 포인트로 충전한 뒤,
    - 50개 스레드가 동시에 `use(1L, 1_000)` 호출
    - 일부 요청은 성공하고, 나머지는 `IllegalStateException(잔고 부족)` 이 발생해야 한다.
    - 최종 잔액이 0 이상이고, 성공한 사용 횟수 × 1_000 이 초기 잔액을 넘지 않는지 검증한다.
    - 동시성 제어가 없다면, 실제 잔액보다 더 많은 금액이 차감되어 음수 잔액이 될 가능성이 있다.

이 테스트들을 통해, **동시에 여러 요청이 들어와도 같은 유저에 대한 포인트 변경이 순차적으로 처리**됨을 확인하였다.
